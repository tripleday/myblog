<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[推荐系统中NMF的一点看法]]></title>
      <url>http://tripleday.github.io/2017/01/12/sparse-nmf/</url>
      <content type="html"><![CDATA[<p>NMF（Non-negative Matrix Factorization），即<strong>非负</strong>矩阵分解，它可以简单定义为：给定矩阵$X∈R_+^{(n×m)}$，寻找非负矩阵$W∈R_+^{(n×k)}$和非负矩阵$H∈R_+^{(k×m)}$，使得$X≈WH$。其简单的直观表示如下图所示：<br><img src="/uploads/img/20170112/mf.png" alt=""><br>在计算中等式左右很难完全相等。在计算中往往是根据某更新法则迭代更新出两个乘子，当上式左右两端的距离（如欧式距离）满足我们设定的大小，停止迭代。它的目标很明确，就是将大矩阵分解成两个小矩阵，使得这两个小矩阵相乘后能够还原到大矩阵，而非负表示分解的矩阵都不包含负值。矩阵分解能够用于发现两种实体间的潜在特征，一个最常见的应用就是协同过滤中的预测打分值，即采用矩阵分解来进行用户推荐，而从协同过滤的这个角度来说，矩阵的非负性也很容易理解：用户打分都是正的，不会出现负值。</p>
<p>在例如MovieLens这样的推荐系统中，有用户和电影两个集合。给出每个用户对部分电影的打分，我们希望预测该用户对其他没看过电影的打分值，这样可以根据打分值为其做出推荐。用户和电影的关系，可以用一个矩阵来表示，每一行表示用户，每一列表示电影，每个元素的值表示用户（User）对已经看过的电影（Item）的打分（1-5分），矩阵形如下表，表中的 – 代表该用户未对此电影打分：<br><img src="/uploads/img/20170112/rank.png" alt=""></p>
<p>在对上述矩阵进行矩阵分解时，我们希望得到如下图的矩阵乘积，为方便理解和之后的可视化操作，我们假设特征（Feature）的数量K为2：<br><img src="/uploads/img/20170112/f.png" alt=""></p>
<p>图中$X$为原始的评分矩阵，$W$为用户对特征的偏好程度矩阵，$H$为电影对特征的拥有程度矩阵。$W$的每一行表示用户，每一列表示一个特征，它们的值表示用户与某一特征的相关性，值越大，表明特征越明显。同理，$H$的每一行表示电影，每一列表示电影与特征的关联。最后为了预测用户算$U_i$对特定电影$I_j$的评分，我们可以直接计算$U_i$和$I_j$对应的特征向量的点积。</p>
<p>使用矩阵分解来预测评分的思想来源于，我们可以通过矩阵分解来发现一些用户打分的潜在特征。比如两个人都喜欢某一演员，那他们就倾向于给TA演的电影打高分；或者两个人都喜欢动作片，则他们会偏向给动作片好评。假如我们能够发现这些特征，我们就能够预测特定用户对特定电影的打分。通常情况下，我们假设特征的数量少于用户和电影的数量，但同时也必须保证不能过少或过多，否则会陷入欠拟合和过拟合的情况。</p>
<p>接下来是我有些不解的地方：在实际生活中，我们有时很难拿到用户所有的打分值，所以得到的用户评分是一个非常<strong>稀疏</strong>的矩阵。由于NMF分解是对原矩阵的近似还原分解，所以该算法会尽力去拟合原矩阵中的大量的<strong>零值点</strong>，这对于其他项目的评分预测都是相当不准确的。所以我想尝试利用梯度下降的方法，只去拟合那些非零值，以期可以忽略零值对分解结果的影响。</p>
<h1 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h1><ul>
<li><p>误差函数<br>$$error=\sum\limits_{i,j}^{X_{ij}&gt;0} [X_{ij}-(WH)_{ij}]^2$$<br>计算预测评分与原始评分之差的平方和，并将之作为误差函数进行最优化，其中的计算项只包括原始评分不为零的评分项。</p>
</li>
<li><p>正则化项<br>$$reg=β(‖W‖^2+‖H‖^2)$$<br>上式中，$β$为权重，$‖W‖^2$和$‖H‖^2$分别为矩阵$W$和$H$的L2范数，即矩阵中所有元素的平方和。</p>
</li>
<li><p>目标函数<br>$$T(W,H)=\sum\limits_{i,j}^{X_{ij}&gt;0} [X_{ij}-(WH)_{ij}]^2+β(‖W‖^2+‖H‖^2)$$</p>
</li>
</ul>
<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><ul>
<li><p>计算偏导<br>$$\frac{∂T(W,H)}{∂W_{ik}}=-\sum\limits_{i,j}^{X_{ij}&gt;0} \sum\limits_k 2(X_{ij}-(WH)_{ij})H_{kj}+2βW_{ik}$$<br>$$\frac{∂T(W,H)}{∂H_{kj}}=-\sum\limits_{i,j}^{X_{ij}&gt;0} \sum\limits_k 2(X_{ij}-(WH)_{ij})W_{ik}+2βH_{kj}$$<br>上式中，我只考虑原始矩阵中的非零元素，因为其中的零值只代表用户未对电影做出评分，并不代表该用户对此电影的评分就是0，所以我们在计算时不对零值进行拟合。</p>
</li>
<li><p>迭代更新<br>$$W_{ik}=W_{ik}+α(\sum\limits_{i,j}^{X_{ij}&gt;0} \sum\limits_k (X_{ij}-(WH)_{ij})H_{kj}-βW_{ik})$$<br>$$H_{kj}=H_{kj}+α(\sum\limits_{i,j}^{X_{ij}&gt;0} \sum\limits_k (X_{ij}-(WH)_{ij})W_{ik}-βH_{kj})$$<br>其中，$α$是学习速率，即每次前进的步长，$α$越大，迭代下降的越快。上式中，我们将因子2提取出来计入$α$，简化表达式。</p>
</li>
</ul>
<h1 id="非负性保证"><a href="#非负性保证" class="headerlink" title="非负性保证"></a>非负性保证</h1><p>传统NMF中，如<a href="http://blog.csdn.net/acdreamers/article/details/44663421" target="_blank" rel="external">非负矩阵分解（NMF）</a>中所示的高斯分布噪声下，可以转化为矩阵乘法的迭代，从而保证非负性。而这里情况就不同，我没有依据地自创了两个条件保证非负性。</p>
<ul>
<li><p>$W$与$H$的初始化<br>随机初始化时保证所有元素均为非负数，则能够在后续迭代中提供一个很好的非负性保证。<br>事实上，$W$与$H$的结果对初始状态是非常敏感的。我在实现时参考了sklearn里nmf采用的一种基于svd分解的初始化方法。</p>
</li>
<li><p>学习速率递减<br>在$W_{ik}$或者$H_{kj}$在梯度下降时，如果某个元素值即将发生由非负到负的转变时，我们将学习速率自动减半，重新进行迭代计算，如果仍然产生负值，则重复上述步骤，当学习速率减半操作次数达到一定阈值时，我们则判定该元素无法继续进行迭代，保持原来的数值不变。<br>这点没有什么理论支撑，纯属自己臆想。</p>
</li>
</ul>
<h1 id="推荐应用"><a href="#推荐应用" class="headerlink" title="推荐应用"></a>推荐应用</h1><p>假设有如下所示的用户对电影的评分矩阵：<br><img src="/uploads/img/20170112/x.png" alt=""><br>对其做非负矩阵分解，可得$W$矩阵和$H$矩阵：<br><img src="/uploads/img/20170112/w.png" alt=""><br><img src="/uploads/img/20170112/h.png" alt=""><br>我们将$W$和$H$矩阵相乘，可以重构还原得到如下矩阵：<br><img src="/uploads/img/20170112/wh.png" alt=""></p>
<p>可以看到，重构还原后的矩阵$V$跟原矩阵$X$很接近，并且对原来空缺的值作出了预测。我们在这些结果的基础上,通过计算用户间或电影间的相似度，进行一些推荐的应用，可以参考博客<a href="http://www.letiantian.me/2015-05-25-nmf-svd-recommend/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">矩阵分解在推荐系统中的应用：NMF和经典SVD实战</a>。</p>
<h1 id="与SVD和NMF的对比"><a href="#与SVD和NMF的对比" class="headerlink" title="与SVD和NMF的对比"></a>与SVD和NMF的对比</h1><p>相关代码上传至Github，附上<a href="https://github.com/tripleday/sparse_NMF" target="_blank" rel="external">链接</a>，很杂乱。</p>
<p>我使用了MovieLens推荐系统的公开100K实验数据集，为了比较本文算法在评分较少的稀疏矩阵中的效果，实验中选取了已看电影不超过100部的观众，根据其对一些电影的评价来预测对其他部分电影的评分。训练集中选取了655个人对1342部电影的评分，分数仅限1,2,3,4,5这五种打分，测试数据集是对应观众对其他部分电影的评分。</p>
<p>实验采用的算法除了本文的稀疏矩阵分解（Sparse NMF），还有现有的奇异值矩阵分解法（SVD）和非负矩阵分解法（NMF），以及评分全为3分的平均值矩阵（Average）来做比较。算法的预测评分中，小于1分的将被划为1，大于5分的将被划为5。实验中采用的误差评价为测试集中有效评分与算法预测评分差的平方和，公式表示如下：<br>$$error=\sum\limits_{i,j}^{X_{ij}&gt;0} [X_{ij}-V_{ij}]^2$$</p>
<p>上式中$X_{ij}$表示用户$i$对电影$j$的实际评分，$V_{ij}$表示用户$i$对电影$j$的预测评分。实验得到的结果对比如下图：<br><img src="/uploads/img/20170112/figure.png" alt=""><br>上图中的横坐标components数目是上面提到的特征数量K。</p>
<p>由于SVD矩阵分解和NMF分解都是对原矩阵的近似还原分解，所以这两种算法会尽力去拟合原矩阵中的大量的零值点，这对于其他电影的评分预测都是相当不准确的。他们的性能甚至比平均值猜测都差很多，所以在稀疏的评分矩阵中，SVD矩阵分解和NMF分解都是不太合适的。而本文的Sparse NMF误差大约为平均值的70%，有一定的效果，但仍有很大的改善空间。</p>
<p>吐槽：</p>
<ul>
<li>我这种一个元素一个元素计算的方法效率很低，没考虑优化的问题。</li>
<li>我还试过另外一种方法，将所有空缺值用所有其他非零项平均值填补，之后再使用SVD或者NMF，效果比不填补使用Sparse NMF要好，填补再用Sparse NMF我也没试过。</li>
</ul>
<p>以上均为本小白个人理解，如有任何不当或者错误，欢迎指正。<br>本文有参考以下博文：</p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_9ce5a1b501018vb2.html" target="_blank" rel="external">NMF算法简介及python实现</a></li>
<li><a href="http://blog.csdn.net/harryhuang1990/article/details/9924377" target="_blank" rel="external">使用LFM（Latent factor model）隐语义模型进行Top-N推荐</a></li>
<li><a href="http://blog.csdn.net/sun_168/article/details/20637833" target="_blank" rel="external">浅谈矩阵分解在推荐系统中的应用</a></li>
<li><a href="http://www.dataguru.cn/thread-484000-1-1.html" target="_blank" rel="external">矩阵分解在推荐系统中的应用</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS下使用Graphite监测scrapy]]></title>
      <url>http://tripleday.github.io/2016/10/06/graphite/</url>
      <content type="html"><![CDATA[<p>一直在做分布式爬虫的项目。项目都是要验收的，给领导验收就需要一些可视化的呈现，因为爬虫本身就算你采用了各种了不得的技术，命令行一启动什么都没有的看，控制台的输出和日志不是程序员估计也不会有什么兴趣。</p>
<p>受github上一个前人的<a href="https://github.com/gnemoug/distribute_crawler" target="_blank" rel="external">爬虫项目</a>的指导，我学习了里面使用Graphite监控的部分，在这篇博客里把我在安装和使用中遇到的问题全部记录下来。</p>
<h1 id="Graphite简介"><a href="#Graphite简介" class="headerlink" title="Graphite简介"></a>Graphite简介</h1><p>Graphite是一个Python编写的企业级开源监控工具，采用django框架，用来收集服务器所有的即时状态，用户请求信息，Memcached命中率,RabbitMQ消息服务器的状态，操作系统的负载状态。Graphite服务器大约每分钟需要有4800次的跟新操作，它采用简单的文本协议和绘图功能，可以方便的使用在任何操作系统上。Graphite 自己本身并不收集具体的数据，这些数据收集的具体工作通常由第三方工具或插件完成（如 Ganglia, collectd, statsd, Collectl 等)。</p>
<p>简单来说，Graphite主要做两件事情：</p>
<ul>
<li>实时监控第三方工具传来的数据</li>
<li>根据数据绘制图形</li>
</ul>
<p>Graphite包含3个组件，carbon，whisper，graphite webapp其中：</p>
<ul>
<li>carbon    - 用于监控数据的 Twisted 守护进程</li>
<li>whisper    - 用于存放和操作数据的库</li>
<li>graphite webapp    - 用于绘制图形的Django webapp</li>
</ul>
<p>关于Graphite的详细官方文档可以参考<a href="http://graphite.readthedocs.io/en/latest/" target="_blank" rel="external">Graphite Documentation</a>。</p>
<h1 id="Graphite安装"><a href="#Graphite安装" class="headerlink" title="Graphite安装"></a>Graphite安装</h1><p>Graphite的安装，我更多地参考了这一篇博客<a href="https://my.oschina.net/duoduo3369/blog/338142#OSC_h2_4" target="_blank" rel="external">用graphite diamond做监控</a>。</p>
<p>首先，我的安装环境是CentOS 6.6，Python2.7.10。</p>
<p>在python等开发环境都安装OK之后，我们使用pip安装Graphite的三个组件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install whisper</span><br><span class="line">pip install carbon</span><br><span class="line">pip install graphite-web</span><br></pre></td></tr></table></figure></p>
<p>这样的方法会将它们安装在默认路径/opt/graphite下。安装完成后，你会发现/opt/graphite下多了一堆东西，将/opt/graphite/conf下的*.example,拷贝到去掉example即可。</p>
<p>启动carbon，carbon会在默认的2003端口接收数据。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /opt/graphite/bin/carbon-cache.py start</span><br></pre></td></tr></table></figure></p>
<p>启动django，即整个Graphite的web应用。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /opt/graphite/webapp/graphite/manage.py runserver 0.0.0.0:12222</span><br></pre></td></tr></table></figure></p>
<p>其中的12222号端口可以自己任意修改。<br>这样浏览器打开<code>http://127.0.0.1:12222</code>就可以看到Graphite的界面。 </p>
<p><strong>然而启动django这一步我在运行的时候遇到了各种错误。</strong></p>
<ul>
<li>在我<code>pip install</code>的django最新版本为2.0的时候，我遇到了大量有关pattern的错误，我按照网上说的全部更改之后还是无法运行，所以弃掉2.0。</li>
<li><p>然而我<code>pip install django==1.9</code>之后，还是遇到了</p>
<ul>
<li>no such table: auth_user</li>
<li>no such table: account_profile</li>
<li>Unknown command: ‘syncdb’</li>
</ul>
<p>这三种错误，发生的先后顺序不一定准，但我在疯狂查阅各种资料之后还是没有成功解决。</p>
</li>
<li>这些错误都是因为django版本不兼容导致的，在我<code>pip install django==1.8</code>之后，整个世界就清静了。</li>
</ul>
<p>如果这时候以为打开浏览器就能看到界面的话，那你还是太年轻了。命令行能够运行没错，但是web可视化的界面还是有错！<br>Graphite界面会提示<code>import cairo</code>出错，这个cairo也是个大坑，原因就是你没有安装cairo图形库，<code>pip install cairo</code>之后你终于能松一口气欣赏一下Graphite了。</p>
<p>页面右上角的dashboard页面可以玩一下，有很多高阶的功能，你会看到左侧tree那边有一些数据，这些数据存储在<code>/opt/graphite/storage/whisper</code>。</p>
<p>另外，Graphite有个<strong>时区设置</strong>的问题，如果不更改，你的时间显示都是GMT时间。只需将<code>/opt/graphite/webapp/graphite/local_settings.py</code>文件里的TIME_ZONE配置改成如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set your local timezone (Django's default is America/Chicago)</span></span><br><span class="line"><span class="comment"># If your graphs appear to be offset by a couple hours then this probably</span></span><br><span class="line"><span class="comment"># needs to be explicitly set to your local timezone.</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure></p>
<p>如果之后想对Graphite的详细架构和具体配置有更深入的了解的话，推荐两个链接：</p>
<ul>
<li><a href="https://github.com/springside/springside4/wiki/Graphite" target="_blank" rel="external">Graphite</a></li>
<li><a href="http://m.linuxeden.com/wap.php?action=article&amp;id=159746" target="_blank" rel="external">Graphite监控新手入门 </a></li>
</ul>
<h1 id="Graphite与scrapy的结合"><a href="#Graphite与scrapy的结合" class="headerlink" title="Graphite与scrapy的结合"></a>Graphite与scrapy的结合</h1><p>结合的方法详见原作者项目中<a href="https://github.com/gnemoug/distribute_crawler/blob/master/woaidu_crawler/woaidu_crawler/statscol/graphite.py" target="_blank" rel="external">graphite.py</a>文件中的注释，我总结为一下几点：</p>
<ul>
<li>把<code>/opt/graphite/webapp/content/js/composer_widgets.js</code>文件中<code>toggleAutoRefresh</code>函数里的interval变量从60改为1。</li>
<li><p>在配置文件<code>storage-aggregation.conf</code>里添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[scrapy_min]</span><br><span class="line">pattern = ^scrapy\..*_min$</span><br><span class="line">xFilesFactor = 0.1</span><br><span class="line">aggregationMethod = min</span><br><span class="line">[scrapy_max]</span><br><span class="line">pattern = ^scrapy\..*_max$</span><br><span class="line">xFilesFactor = 0.1</span><br><span class="line">aggregationMethod = max</span><br><span class="line">[scrapy_sum]</span><br><span class="line">pattern = ^scrapy\..*_count$</span><br><span class="line">xFilesFactor = 0.1</span><br><span class="line">aggregationMethod = sum</span><br></pre></td></tr></table></figure>
</li>
<li><p>在爬虫的配置文件<code>setting.py</code>里添加</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATS_CLASS = <span class="string">'scrapygraphite.GraphiteStatsCollector'</span></span><br><span class="line">GRAPHITE_HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">GRAPHITE_PORT = <span class="number">2003</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后两点是我自己的修改。<br>scrapy本身提供的状态记录偏少，且缺乏实时的速度信息，都是不断增长式的总和记录。我想让scrapy能够定时发送pages的抓取速度和item的生成速度给Graphite，所以我在scrapy源码的<code>scrapy/extensions/logstats.py</code>文件中添加了两个状态变量的发送。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider_opened</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">    self.pagesprev = <span class="number">0</span></span><br><span class="line">    self.itemsprev = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    self.task = task.LoopingCall(self.log, spider)</span><br><span class="line">    self.task.start(self.interval)</span><br><span class="line"></span><br><span class="line">    self.stats.set_value(<span class="string">'pages_min'</span>, <span class="number">0</span>, spider=spider)</span><br><span class="line">    self.stats.set_value(<span class="string">'items_min'</span>, <span class="number">0</span>, spider=spider)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">    items = self.stats.get_value(<span class="string">'item_scraped_count'</span>, <span class="number">0</span>)</span><br><span class="line">    pages = self.stats.get_value(<span class="string">'response_received_count'</span>, <span class="number">0</span>)</span><br><span class="line">    irate = (items - self.itemsprev) * self.multiplier</span><br><span class="line">    prate = (pages - self.pagesprev) * self.multiplier</span><br><span class="line">    self.pagesprev, self.itemsprev = pages, items</span><br><span class="line"></span><br><span class="line">    msg = (<span class="string">"Crawled %(pages)d pages (at %(pagerate)d pages/min), "</span></span><br><span class="line">           <span class="string">"scraped %(items)d items (at %(itemrate)d items/min)"</span>)</span><br><span class="line">    log_args = &#123;<span class="string">'pages'</span>: pages, <span class="string">'pagerate'</span>: prate,</span><br><span class="line">                <span class="string">'items'</span>: items, <span class="string">'itemrate'</span>: irate&#125;</span><br><span class="line">    logger.info(msg, log_args, extra=&#123;<span class="string">'spider'</span>: spider&#125;)</span><br><span class="line">    self.stats.set_value(<span class="string">'pages_min'</span>, prate, spider=spider)</span><br><span class="line">    self.stats.set_value(<span class="string">'items_min'</span>, irate, spider=spider)</span><br><span class="line">    states = self.stats.get_stats()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> states:</span><br><span class="line">        self.stats._set_value(key, states[key], spider=spider)</span><br></pre></td></tr></table></figure>
<p>这里的log函数每隔interval的秒数就会执行一次，interval的值可以在setting里配置<code>LOGSTATS_INTERVAL</code>的值。因为scrapy里的状态值很多是在增长时才会调用inc_value去加一改变大小，数据不增长就不会变，也不会去发送给Graphite。所以我在定时执行的log函数里强行再去发送一下数据，不管值有没有改变，即最后的三行代码。虽然我感觉在Graphite的显示里这样做好像并没有什么效果。</p>
</li>
<li><p>在数据的分布定义storage-schemas.conf中，默认是按60秒一个数据的方式，存一天的数据，一天前的数据就没了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[default_1min_for_1day]</span><br><span class="line">pattern = .*</span><br><span class="line">retentions = 60s:1d</span><br></pre></td></tr></table></figure>
<p>但是爬虫的数据60s存一个数据显得有点稀疏，特别是在想要显示实时抓取速度时候，这里可以根据不同需求进行更改。</p>
</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>贴一个Graphite的效果图：<br><img src="/uploads/img/20161006/graphite.png" alt="Graphite"><br>如果嫌原版Graphite界面丑，据说可以使用豆瓣写的皮肤<a href="https://github.com/douban/graph-index" target="_blank" rel="external">graph-index</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NLP中使用HMM进行tag、seg和ner]]></title>
      <url>http://tripleday.github.io/2016/07/28/hmm4nlp/</url>
      <content type="html"><![CDATA[<p>看到网上有很多分词、词性标注的工具，但大多是已经训练过的模型，有些可以添加一些自定义的词典来定制模型。趁同学给了我一些nlp的中文语料数据，我就尝试自己实现一个简单的HMM（隐马尔科夫模型）来进行中文的词性标注（Part-of-Speech tagging或POS tagging，以下简称<strong>tag</strong>）、分词（Segmentation，以下简称<strong>seg</strong>）和命名实体识别（Named Entity Recognition，以下简称<strong>ner</strong>）。</p>
<p>具体关于HMM的内容，这篇博文里面不做赘述，读者可以自行学习了解，也可以参考本人之前的一篇博文<a href="http://tripleday.github.io/2016/07/14/hmm-memm-crf/">HMM、MEMM和CRF的学习总结</a>和里面提供的一些链接。</p>
<h1 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h1><p>整个HMM的代码和相关测试数据已上传至Github上，附上<a href="https://github.com/tripleday/simple_HMM" target="_blank" rel="external">链接</a>。整个代码的实现有部分学习参考博客<a href="http://blog.csdn.net/soundfuture/article/details/4135216" target="_blank" rel="external">python词法分析(分词+词性标注）</a>，感谢博主的分享。</p>
<ul>
<li><p>文件图如下：<br><img src="/uploads/img/20160728/file.png" alt=""><br>这四个文件夹中都是用的是同一个HMM模型，只是测试数据和目标任务不同而已。其中tag相关的有两个：conll_tag和pku_tag，conll_tag使用的CoNLL-2000的英文数据，具体数据下载见<a href="http://www.cnts.ua.ac.be/conll2000/chunking/" target="_blank" rel="external">Chunking</a>，pku_tag使用的一个北大同学给的课程作业的中文语料数据。pku_seg和pku_ner同理分别是在相应的数据上进行的分词和命名实体识别。</p>
</li>
<li><p>其实，seg和ner的实现依赖于tag的词性标注，只是seg、ner要学习的的标签不同。整个HMM的实现也中规中矩，从语料数据中学习转移概率、发射概率等等，然后利用viterbi算法求解最大路径。其中在计算路径概率的时候，为了防止概率相乘过小约等于零的情况，程序取概率对数再取反，将概率相乘转化为对数相加。</p>
</li>
</ul>
<h1 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h1><ul>
<li><p>数据说明<br>tag这里指语句的词性标注，当然不同的语料采用的词性体系不太相同。</p>
<ul>
<li>conll2000为英文语料，给出的数据一共有三列，每一列代表的含义在上面给出的链接里有提及。第一列是英文单词本身，<strong>第二列</strong>是由Brill tagger标注的词性，<strong>第三列</strong>是华尔街日报语料库产生的标注，其实第三列的标注和分词的标注方法类似。</li>
<li>pku的数据是中文语料，且已经进行过分词操作，它的词性标注与<a href="http://wenku.baidu.com/view/3c5488b75ef7ba0d4b733b1a" target="_blank" rel="external">近代汉语词类标注简表</a>相似但不完全相同。</li>
</ul>
</li>
<li><p>测试结果<br>关于准确率，程序将数据七三分做交叉验证来计算。conll2000对第二列的<strong>Brill tagger</strong>的准确率约为94.09%，对第三列的<strong>WSJ corpus</strong>的准确率约为87.93%。pku的准确率约为93.0%。</p>
</li>
<li><p>结果分析</p>
<ul>
<li>本文实现的HMM对实际详细的词性标注如conll的Brill tagger和pku的标注有较好的效果，而conll的WSJ corpus的标注偏向语句的分词，效果会差一些。</li>
<li>我实现的HMM在训练完进行标注的时候，没有去检测一些数字，日期等等的存在，而是单纯地看它在不在训练集里，比如之前训练时统计到过6.11是数字，但没见过6.12，那之后就标注不出来了。这是很大一块需要改进的地方。</li>
</ul>
</li>
</ul>
<h1 id="seg"><a href="#seg" class="headerlink" title="seg"></a>seg</h1><ul>
<li><p>处理思路<br>seg的处理思路就是将训练数据转化为上一项tag（POS Tagging）所需的训练数据格式，程序里我采用的是4-tag（B（Begin，词首）, E（End，词尾）, M（Middle，词中）, S（Single,单字词））标记集。这里转化来转化去的脚本需要自己写。关于这种标记方法和转化过程的详细介绍可以参考这篇<a href="http://www.52nlp.cn/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E6%A0%87%E6%B3%A8%E6%B3%953" target="_blank" rel="external">中文分词入门之字标注法3</a>。</p>
</li>
<li><p>测试结果<br>对pku的数据测试得到的准确率为92.13%，召回率为91.88%，F1值为92.01%。</p>
</li>
</ul>
<h1 id="ner"><a href="#ner" class="headerlink" title="ner"></a>ner</h1><ul>
<li><p>数据说明<br>ner的训练数据里，非命名实体的都标注为N，“北京市”中“北”标为“B-LOC”，代表为地名的开始，“京”和“市”跟在后面则标为“I-LOC”。在最后计算准确率和召回率的时候，标为“N”的字都不需要考虑，仅看那些命名实体是否被标注出来。</p>
</li>
<li><p>测试结果<br>对pku的数据测试得到的准确率为67.6%，召回率为63.9%，F1值为65.7%。</p>
</li>
<li><p>结果分析<br>从结果可以看出，在不使用规则或字典等其他方法干预的情况下，单纯使用HMM对命名实体识别效果较差。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用python将图片转化为字符画]]></title>
      <url>http://tripleday.github.io/2016/07/20/img2txt/</url>
      <content type="html"><![CDATA[<p>忽然想玩这个图片转化的把戏，是因为之前在知乎上看到一个专栏里用到了下面这个图：<br><img src="/uploads/img/20160720/mo.jpg" alt="拿衣服"><br>当然，那篇专栏没过几小时就被和谐了。我在网上貌似搜到了这个图片转emoji mosaic的网址，供大家戏耍：<a href="http://ericandrewlewis.github.io/emoji-mosaic/" target="_blank" rel="external">Emoji Mosaic</a>。</p>
<p>做这个转emoji马赛克应该蛮复杂的，当然它的源码也很容易找到：<a href="https://github.com/ericandrewlewis/emoji-mosaic" target="_blank" rel="external">ericandrewlewis/emoji-mosaic</a>。但我纯属娱乐又不想花功夫，于是就在晚上学了学把图片转为字符图的代码玩玩。</p>
<p>代码很简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"> </span><br><span class="line">grey2char = [<span class="string">'@'</span>,<span class="string">'#'</span>,<span class="string">'$'</span>,<span class="string">'%'</span>,<span class="string">'&amp;'</span>,<span class="string">'?'</span>,<span class="string">'*'</span>,<span class="string">'o'</span>,<span class="string">'/'</span>,<span class="string">'&#123;'</span>,<span class="string">'['</span>,<span class="string">'('</span>,<span class="string">'|'</span>,<span class="string">'!'</span>,<span class="string">'^'</span>,<span class="string">'~'</span>,<span class="string">'-'</span>,<span class="string">'_'</span>,<span class="string">':'</span>,<span class="string">';'</span>,<span class="string">','</span>,<span class="string">'.'</span>,<span class="string">'`'</span>,<span class="string">' '</span>]</span><br><span class="line">count = len(grey2char)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toText</span><span class="params">(image_file)</span>:</span></span><br><span class="line">   image_file = image_file.convert(<span class="string">'L'</span>)<span class="comment"># 转灰度</span></span><br><span class="line">   result = <span class="string">''</span><span class="comment"># 储存字符串</span></span><br><span class="line">   <span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">0</span>,  image_file.size[<span class="number">1</span>]):<span class="comment"># height</span></span><br><span class="line">      <span class="keyword">for</span> w <span class="keyword">in</span> range(<span class="number">0</span>, image_file.size[<span class="number">0</span>]):<span class="comment"># width</span></span><br><span class="line">         gray = image_file.getpixel((w,h))</span><br><span class="line">         result += grey2char[int(gray/(<span class="number">255</span>/(count<span class="number">-1</span>)))]</span><br><span class="line">      result += <span class="string">'\r\n'</span></span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">image_file = Image.open(<span class="string">"input.jpg"</span>)<span class="comment"># 打开图片</span></span><br><span class="line">image_file = image_file.resize((int(image_file.size[<span class="number">0</span>]), int(image_file.size[<span class="number">1</span>]*<span class="number">0.55</span>)))<span class="comment"># 调整图片大小</span></span><br><span class="line"> </span><br><span class="line">output = open(<span class="string">'output.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">output.write(toText(image_file))</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是要安装依赖PIL。</p>
<p>原图：<br><img src="/uploads/img/20160720/input.jpg" alt=""></p>
<p>字符图：<br><img src="/uploads/img/20160720/cover.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HMM、MEMM和CRF的学习总结]]></title>
      <url>http://tripleday.github.io/2016/07/14/hmm-memm-crf/</url>
      <content type="html"><![CDATA[<p>最近一直在学习NLP里最基础的几个语言模型：<strong>隐马尔科夫模型</strong>（Hidden Markov Model，HMM）、<strong>最大熵马尔科夫模型</strong>（Maximum Entropy Markov Model，MEMM）和<strong>条件随机场</strong>（Conditional Random Field，CRF）。这三种模型在自然语言处理中，可以解决分词（segment，Seg）、标注（Tag）和命名实体识别（Named Entity Recognition，Ner）等问题。学习的时候参考最多的两本书是李航老师的<strong>《统计学习方法》</strong>和吴军老师的<strong>《数学之美》</strong>。如需这两本书的电子版可以给我留言。</p>
<p>我先分别简单介绍一下几种模型，具体的推导过程就不列出来，《统计学习方法》上有非常详细的数学原理。</p>
<h1 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h1><p>下图是《统计学习方法》中的描述：<br><img src="/uploads/img/20160714/hmm.png" alt="隐马尔科夫模型"><br>HMM模型将状态序列看作马尔可夫链，一阶马尔可夫链式针对相邻状态的关系进行建模，其中每个状态对应一个概率函数。HMM是一种<strong>生成模型</strong>（Generative Model），定义了联合概率分布 ，其中$x$和$y$分别表示观测序列和状态序列的随机变量。</p>
<p>如果需要一些浅显简单的例子来理解HMM，下面的一个知乎问题和一篇博客可能有所帮助：</p>
<ul>
<li><a href="https://www.zhihu.com/question/20962240" target="_blank" rel="external">如何用简单易懂的例子解释隐马尔可夫模型？</a></li>
<li><a href="http://blog.csdn.net/likelet/article/details/7056068" target="_blank" rel="external">隐马尔可夫模型（HMM）攻略</a></li>
</ul>
<h1 id="Maximum-Entropy-Model"><a href="#Maximum-Entropy-Model" class="headerlink" title="Maximum Entropy Model"></a>Maximum Entropy Model</h1><p>首先贴一下关于最大熵模型的定义：<br><img src="/uploads/img/20160714/me.png" alt="最大熵模型"><br>最大熵模型的基本思想就是不要把所有鸡蛋放到一个篮子里。式（6.12）中的$f_i$是<strong>特征函数</strong>，代表各个约束条件。最大熵模型就是在符合所有约束条件下作出<strong>最不偏倚</strong>的假设，求得可使熵最大化的概率分布。熵最大，表示该系统内各随机事件(变量)发生的概率是近似均匀的，等可能性的。</p>
<p>最大熵模型可以使用任意的复杂相关特征（即特征函数），在性能上最大熵分类器超过了Bayes分类器。但是，作为一种分类器模型，这两种方法有一个共同的缺点：每个词都是单独进行分类的，标记状态之间的关系无法得到充分利用，具有马尔可夫链的HMM模型可以建立标记之间的马尔可夫关联性，这是最大熵模型所没有的。</p>
<p>最大熵模型的<strong>优点</strong>：首先，最大熵统计模型获得的是所有满足约束条件的模型中信息熵极大的模型;其次，最大熵统计模型可以灵活地设置约束条件，通过约束条件的多少可以调节模型对未知数据的适应度和对已知数据的拟合程度;再次，它还能自然地解决了统计模型中参数平滑的问题。</p>
<p>最大熵模型的<strong>不足</strong>：首先，最大熵统计模型中二值化特征只是记录特征的出现是否，而文本分类需要知道特征的强度，因此，它在分类方法中不是最优的;其次，由于算法收敛的速度较慢，所以导致最大熵统计模型它的计算代价较大，时空开销大;再次，数据稀疏问题比较严重。</p>
<h1 id="MEMM"><a href="#MEMM" class="headerlink" title="MEMM"></a>MEMM</h1><p>最大熵马尔科夫模型把HMM模型和Maximum Entropy模型的优点集合成一种<strong>生成模型</strong>（Generative Model），这个模型允许状态转移概率依赖于序列中彼此之间非独立的特征上，从而将上下文信息引入到模型的学习和识别过程中，提高了识别的精确度，召回率也大大的提高，有实验证明，这个新的模型在序列标注任务上表现的比HMM和无状态的最大熵模型要好得多。<br><img src="/uploads/img/20160714/memm.png" alt="最大熵马尔科夫模型"><br>可以注意到MEMM在每个节点对所有可能的状态$y$求和然后用做局部归一化的分母。所以MEMM中节点状态转移的概率都是归一化的概率。</p>
<p>HMM模型中存在两个假设：一是输出观察值之间严格独立，二是状态的转移过程中当前状态只与前一状态有关(一阶马尔可夫模型)。但MEMM模型克服了观察值之间严格独立产生的问题，但是由于状态之间的假设理论，使得该模型仍然存在<strong>标注偏置问题</strong>（Label Bias Problem）。</p>
<p>关于标注偏置问题，网上最多的是下面这个例子解释：<br><img src="/uploads/img/20160714/label-bias-1.png" alt=""><br>路径1-1-1-1的概率：0.4*0.45*0.5=0.09<br>路径2-2-2-2的概率：0.018<br>路径1-2-1-2的概率：0.06<br>路径1-1-2-2的概率：0.066<br>由此可得最优路径为：1-1-1-1<br><img src="/uploads/img/20160714/label-bias-2.png" alt=""><br>而实际上，在上图中，状态1偏向于转移到状态2，而状态2总倾向于停留在状态2，这就是所谓的标注偏置问题，由于分支数不同，概率的分布不均衡，导致状态的转移存在不公平的情况。<br>例子的出处参见<a href="http://blog.csdn.net/lskyne/article/details/8669301" target="_blank" rel="external">标注偏置问题(Label Bias Problem)和HMM、MEMM、CRF模型比较</a></p>
<h1 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h1><p><img src="/uploads/img/20160714/crf-1.png" alt="线性链条件随机场模型"><br>这是书上关于条件随机场的简化形式。本文所提的CRF都不是广义上最大熵准则建模条件概率的条件随机场模型，而是约束在线性链上的特殊的条件随机场，称为线性链条件随机场（linear chain CRF）。CRF属于<strong>判别模型</strong>（Discrimitive Model）。<br><img src="/uploads/img/20160714/crf-2.png" alt="线性链条件随机场模型图示"><br>上式中也同样有$f_i$<strong>特征函数</strong>。之前我对模型中的特征函数一直不太理解。大家可以参考<a href="http://www.52nlp.cn/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E6%A0%87%E6%B3%A8%E6%B3%954" target="_blank" rel="external">中文分词入门之字标注法4</a>这篇文章。文章主要介绍借用条件随机场工具“<a href="http://tenet.dl.sourceforge.net/project/crfpp/crfpp-win32/0.54/CRF%2B%2B-0.54.zip" target="_blank" rel="external">CRF++: Yet Another CRF toolkit</a>”来完成字标注中文分词的全过程。其中提及了特征模板文件，它的特征提取可能包含了前后多个节点的观测序列。顺便推荐一下这个非常厉害的群体博客<a href="http://www.52nlp.cn/" target="_blank" rel="external">52nlp</a>。<br>《数学之美》里“徐志摩喜欢林徽因”的例子也可供参考。</p>
<p>CRF模型的<strong>优点</strong>：首先，CRF具有很强的推理能力，并且能够使用复杂、有重叠性和非独立的特征进行训练和推理，能够充分地利用上下文信息作为特征，还可以任意地添加其他外部特征，使得模型能够获取的信息非常丰富。其次，CRF的性能更好，CRF对特征的融合能力比较强，识别效果好于MEMM。</p>
<p>CRF模型的<strong>不足</strong>：使用CRF方法的过程中，特征的选择和优化是影响结果的关键因素，特征选择问题的好与坏，直接决定了系统性能的高低。而且，CRF训练模型的时间较长，且获得的模型很大，在一般的PC机上无法运行。</p>
<p>更多一些详细的CRF解释可以参考知乎的相关问题<a href="https://www.zhihu.com/question/35866596" target="_blank" rel="external">如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？</a></p>
<h1 id="MEMM与CRF区别"><a href="#MEMM与CRF区别" class="headerlink" title="MEMM与CRF区别"></a>MEMM与CRF区别</h1><p>上面的公式都是别人贴图里的，下面的公式是我走心地敲出来的，方便看出两者的差异。</p>
<p>MEMM的公式表示如下：<br>$$<br>\begin{eqnarray*}<br>p(y_1, \ldots, y_T | x_1, \ldots, x_T) &amp;=&amp; \prod_{i=1}^T p(y_i | x_1, \ldots, x_T, y_{i-1}) \\<br>p(y_i | x_1, \ldots, x_T, y_{i-1}) &amp;=&amp;<br>\frac{exp(\sum\limits_{k=1}^K w_{k}f_k(x_1, \ldots, x_T, y_{i-1}, y_i)}<br>{\sum\limits_y exp(\sum\limits_{k=1}^K w_{k}f_k(x_1, \ldots, x_T, y_{i-1}, y)}<br>\end{eqnarray*}<br>$$<br>线性链CRF的公式表示如下：<br>$$<br>\begin{eqnarray*}<br>p(y|x) &amp;=&amp; \frac{p(y, x)}{\sum\limits_Y p(y, x)}<br>\\<br>&amp;=&amp; \frac{\prod\limits_{t=1}^T exp(\sum\limits_{k=1}^K w_k f_k(y_t, y_{t-1}, x))}<br>{\sum\limits_Y \prod\limits_{t=1}^T exp(\sum\limits_{k=1}^K w_k f_k(y_t, y_{t-1}, x)) }<br>\end{eqnarray*}<br>$$<br>不同点：</p>
<ul>
<li>首先，CRF是<strong>判别模型</strong>，而MEMM我个人理解是<strong>生成模型</strong>。MEMM是在HMM基础上的优化，它保留了“状态的转移过程中当前状态只与前一状态有关”这一个独立性假设，状态与状态之间的转移仍是遵循一个<strong>不大于1</strong>的、只在同一结点作归一化的局部归一化概率，与HMM的思想相近。</li>
<li>MEMM和CRF的<strong>归一化位置</strong>不同。从上面的公式可以看出，MEMM是在given前一状态$y_{i-1}$的情况下，对下一个节点所有可能的$y_i$作局部的归一化，利用最大熵模型，从观测序列$x$和前一状态$y_{i-1}$中的特征学习到$y_i$的分布。而CRF是对$Y$中所有可能的状态序列作全局的归一化，假设每个节点有$L$中状态，序列中有$T$个节点，那么所有可能的状态序列数为$L^T$，这导致在模型学习时会较为复杂。</li>
<li>MEMM在用<strong>viterbi算法</strong>求解最优路径时，每次乘上的是个归一化概率，而CRF乘上的是一个自然指数，没有经过归一化。当遇到某些不公平的情况：某条路径自然指数本身很小，但归一化后变为一个很大的概率比如0.9，而同时即使别的路径自然指数很大，但它们竞争也激烈，归一化后的概率反而不大，这样前一条路径就会被选中，导致了之前提过的标记偏置问题，而CRF可以避免这一问题。</li>
</ul>
<p>关于MEMM和CRF两者的区别，推荐可以参考下面的一个知乎问题和一篇博客：</p>
<ul>
<li><a href="https://www.zhihu.com/question/30869789" target="_blank" rel="external">MEMM和CRF有什么不同？</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_8af106960102v0v1.html" target="_blank" rel="external">统计模型之间的比较，HMM，最大熵模型，CRF条件随机场 </a></li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>关于用做封面的那张图，是对相关模型一个非常抽象、宏观的转换图，感觉非常精髓，出处为<a href="http://homepages.inf.ed.ac.uk/csutton/publications/crftut-fnt.pdf" target="_blank" rel="external">An introduction to conditional random fields</a>。</p>
<p>以上均为本小白个人理解，如有任何不当或者错误，欢迎指正。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Neo4j的知乎关系爬虫]]></title>
      <url>http://tripleday.github.io/2016/06/29/zhihu-link/</url>
      <content type="html"><![CDATA[<p>前两天做了一个爬取知乎用户<strong>follow</strong>关系的爬虫。做这个爬虫是受一个知乎专栏的启发<a href="https://zhuanlan.zhihu.com/p/20546546" target="_blank" rel="external">Web Crawler with Python - 09.怎样通过爬虫找出我和轮子哥、四万姐之间的最短关系</a>，我有部分代码参考了xlzd。由于当时也想了解一下NoSQL里Graph Database，于是花了几天时间做了一个简单的爬虫，感觉收获不少。封面图片可以理解成是一个<strong>六度分隔理论</strong>的直观展现，也是我在做爬虫时的意外验证。</p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>首先交代一下爬虫所用到的数据库和环境：</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB一种基于分布式文件存储的数据库，属于NoSQL里的文档型数据库。它的性能较高，面向集合存储，爬虫所抓取的用户信息都存储在其中。<br>在python里使用MongoDB，只需要在本机下载安装MongoDB服务，在python的环境里安装pymongo依赖，<code>pip install pymongo</code>就可以了。如果嫌MongoDB的命令行操作不方便，可以装一个MongoDB的可视化工具<a href="https://robomongo.org/" target="_blank" rel="external">Robomongo</a>。</p>
<h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p>Neo4j是一个高性能的,NoSQL图形数据库，它将结构化数据存储在网络上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。<br>关于Neo4j的安装，可以参考这篇博客<a href="http://blog.csdn.net/dyllove98/article/details/8635965" target="_blank" rel="external">Neo4j介绍与使用</a>。Win7环境下，官网<a href="https://neo4j.com/download/" target="_blank" rel="external">下载</a>可以一键安装Neo4j。</p>
<p>Neo4j使用类似SQL的查询语言<strong>Cypher</strong>，关于Cypher的使用和简单demo，可以参考<a href="http://www.uml.org.cn/sjjm/201203063.asp" target="_blank" rel="external">Cypher查询语言–Neo4j中的SQL</a>。当然，为了减少学习Cypher的时间成本，我在python环境中安装了<strong>py2neo</strong>，<code>pip install py2neo</code>。</p>
<p>py2neo的handbook见<a href="http://py2neo.org/v3/" target="_blank" rel="external">The Py2neo v3 Handbook</a>。我对py2neo依赖库的理解：py2neo是一个Neo4j的客户端，其中对Neo4j的操作进行了封装。调用py2neo的一个函数，它会自动转化为Cypher语言并以HTTP API向Neo4j服务端口提交一个事务。当然它也支持直接提交Cypher语句到Neo4j执行，有些复杂的数据操作比如寻找两点之间最短路径，py2neo没有提供直接的函数调用，需要我们自己编写Cypher。</p>
<h2 id="python依赖"><a href="#python依赖" class="headerlink" title="python依赖"></a>python依赖</h2><ul>
<li>requests<br>requests是一个非常好用的网络依赖包，API文档见<a href="http://www.python-requests.org/en/master/" target="_blank" rel="external">Requests: HTTP for Humans</a>。文档网站的名字“HTTP for Humans”，算是程序员的一种幽默吧。</li>
<li>BeautifulSoup<br>BeautifulSoup依赖库是一个非常实用的HTML解析器，不需要程序员再焦头烂额地写RegEx。虽然开发友好了，但解析时有时会出一些不可思议的bug。API文档见<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="external">Beautiful Soup 4.2.0 文档</a>。</li>
</ul>
<h1 id="爬虫概要"><a href="#爬虫概要" class="headerlink" title="爬虫概要"></a>爬虫概要</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>我爬虫的目的非常简单，和开头的那篇专栏一样：知乎大V—轮子哥（<strong>vczh</strong>）需要通过多少人才能认识并关注我？这里的认识是指单方面的知道，即成为我的follower（不需要为followee，虽然这是肯定的），知道这世界原来还有个知乎用户“<strong>三天三夜</strong>”。</p>
<h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><p>爬虫从我自己的知乎出发，读取我的follower列表，对我的每个follower重复搜索操作，直到搜索到的follower list里有vczh。这个遍历是<strong>BFS</strong>的。当然，为了防止在广度优先搜索时，层与层之间节点数量扩张过快，我限制只搜索follower num<strong>不超过100</strong>的不活跃的小用户，当然我提前调查了轮子哥也有follow一些这种小用户。除了为了防止扩张过快导致的存储空间过大，这样做也给验证六度分隔理论提了更为苛刻的条件，毕竟轮子哥通过其他大V能follow到我的概率是远大于通过小用户的。</p>
<h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><p>整个爬虫的代码我push到Github上，附上<a href="https://github.com/tripleday/zhihu_link" target="_blank" rel="external">链接</a>。<br>贴上几个想到的小细节：</p>
<ul>
<li>这个爬虫需要自己的知乎cookie才能爬取。建议使用chrome，安装<strong>EditThisCookie</strong>插件，将知乎的cookie复制粘贴到zhihu_cookie.json文件。</li>
<li>知乎用户的唯一性不是靠用户名，而是html里内嵌隐藏的<strong>data-id</strong>，在ajax获取数据是发送的表单数据里也需要这个值。所以Neo4j中使用此值可以唯一标识用户。</li>
<li>BeautifulSoup的官方文档里的一张解析器对比表格</li>
</ul>
<p><img src="/uploads/img/20160629/bs.png" alt="BeautifulSoup解析器对比"><br>实际使用中，在解析<code>https://www.zhihu.com/people/hong-ming-da</code>这条链接时，lxml解析一直都会出错，换成html.parser后解析成功。所以html.parser虽然解析速度慢，但容错性更好一点。</p>
<ul>
<li>代码中有关知乎爬虫的代码，我是在<a href="https://github.com/egrcc/zhihu-python" target="_blank" rel="external">egrcc/zhihu-python</a>的基础上改动的，非常感谢原作者的分享。</li>
<li>其他的细节想到后再补充。</li>
</ul>
<h1 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h1><p>爬虫程序在爬了23928个用户才停下来，即找到了轮子哥。这是爬完的部分用户图：<br><img src="/uploads/img/20160629/whole.png" alt="部分用户关系图"></p>
<p>在命令行执行Cypher语句：<code>MATCH (a {_id : &#39;0970f947b898ecc0ec035f9126dd4e08&#39;}), (b {_id : &#39;bd648b6ef0f14880a522e09ce2752465&#39;}), p = allShortestPaths( (a)-[*..200]-&gt;(b) ) RETURN p</code>可以得到轮子哥到我的最短路径：<br><img src="/uploads/img/20160629/shortestpath.png" alt="最短路径图"></p>
<p>可以发现：轮子哥到我，中间正好经过了6个人。这条路的生成条件是较为严格的。不仅是因为我只选择的小用户进行爬取，而且要知道我的follower目前是只有一个的，轮子哥要连接到我只能通过他。虽然实验得到的 <strong>6</strong> 可能和六度分隔理论恰巧吻合，但鉴于路径选择的苛刻条件，六度的6也许并不只是一种猜想。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS 6.5 下scrapy与ghost.py的安装干货]]></title>
      <url>http://tripleday.github.io/2016/06/16/centos-scrapy-ghost.py/</url>
      <content type="html"><![CDATA[<p>之前一直在做scrapy中关于网页动态内容的获取，主要目标是想获得javascript渲染后的网页html源码。<br>在转向使用ghost.py来做脚本解析之前的挖坑爬坑过程中，我已经造访过我所知的大大小小各种论坛、博客以及贴吧和知乎。其中有大方向上指导意义的有知乎里的相关问题：</p>
<ul>
<li><a href="https://www.zhihu.com/question/21471960" target="_blank" rel="external">Python 爬虫如何获取 JS 生成的 URL 和网页内容？</a></li>
<li><a href="https://www.zhihu.com/question/36450326" target="_blank" rel="external">Python爬虫在处理由Javascript动态生成的页面时有哪些解决方案？</a></li>
</ul>
<p>一些前人的技术博客如：</p>
<ul>
<li>开源中国上<a href="http://my.oschina.net/u/1024140?ft=blog" target="_blank" rel="external">斑ban</a>的<a href="http://my.oschina.net/u/1024140/blog/188154" target="_blank" rel="external">《使用python，scrapy写（定制）爬虫的经验，资料，杂》</a>。<br>这篇博客里的总结涉及到爬虫的很多方面，看后受益匪浅，作者乃真大神，有很丰富的爬虫经验。</li>
</ul>
<p>上述几个干货里提到的方法，我基本都去了解了一下，也照着其中的几个方向挖过坑，过些时间我把我在这方面爬的所有坑都总结到一篇博客里。</p>
<p>ghost.py算是我掉坑里时间最长的，也是差点就成功的一个，到现在也弃了，弃的原因日后再说。其实，用ghost.py是在PyQt4的基础上转过去的，ghost.py是对<strong>PyQt4</strong>或者<strong>PySide</strong>的一个封装，需要安装其中一个才能运行。</p>
<h1 id="PySide"><a href="#PySide" class="headerlink" title="PySide"></a>PySide</h1><p>当然挖坑的第一步就是安装环境了，win7上安装简便得多，但到linux下就没那么舒服了。<br>下面是我在CentOS 6.5和python2.7.11的环境上安装scrapy、PySide和Ghost.py过程中查到的有用资料的整合。如嫌下面的字太小，可戳此PDF<a href="http://tripleday.cn/uploads/pdf/CentOS-scrapy-ghost.py.pdf" target="_blank" rel="external">源地址</a>。<br>

	<div class="row">
    <embed src="http://tripleday.github.io/uploads/pdf/CentOS-scrapy-ghost.py.pdf" width="100%" height="550" type="application/pdf">
	</div>


<br>上面的PDF里ghost.py用的是PySide。PySide和PyQt4的功能和API近乎一致，我的理解是：PyQt4是PySide的商业化版本，两者都是Qt进行维护。</p>
<h1 id="PyQt4"><a href="#PyQt4" class="headerlink" title="PyQt4"></a>PyQt4</h1><p>我曾经在用PySide的时候遇到无法解决的Core Dump的bug，想转去试一下PyQt4看会不会好点，虽然结果是bug更频繁，但我还是列出安装PyQt4的一些小tips吧，希望后来人少走点弯路。</p>
<p>安装PyQt4之前是需要安装<strong>SIP</strong>的。SIP是一个自动为C和C++库生成Python扩展模块的工具。为了方便开发PyQt，SIP于1998被“Riverbank Computing”公司创造出来。不过，SIP不专用于PyQt，而是适用于所有的C和C++库。但据说好像现在只有PyQt一直在坚持用SIP，很多别人家的项目在需要对C或C++封装调用的时候都用SWIG了。</p>
<p>在安装过程中最让人抓狂的SIP和PyQt4的版本对应问题：某个固定版本的SIP只能支持少数几个版本的PyQt，有比较麻烦的兼容性问题。曾经在安装时，要么提示SIP版本过高，PyQt无法编译；要么PyQt版本过高，SIP不能支持。<br>贴一个能够成功安装的博客链接：<a href="http://blog.csdn.net/dgatiger/article/details/50331361" target="_blank" rel="external">CentOS7.1下python2.7.10安装PyQt4</a></p>
<p>文中SIP的安装代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/project/pyqt/sip/sip-4.17/sip-4.17.tar.gz</span><br><span class="line">tar xvf sip-4.17.tar.gz</span><br><span class="line"><span class="built_in">cd</span> sip-4.17</span><br><span class="line">python configure.py</span><br><span class="line">make &amp; make install &amp; make clean</span><br></pre></td></tr></table></figure></p>
<p>PyQt的安装代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/project/pyqt/PyQt4/PyQt-4.11.4/PyQt-x11-gpl-4.11.4.tar.gz</span><br><span class="line">tar xvf PyQt-x11-gpl-4.11.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> PyQt-x11-gpl-4.11.4</span><br><span class="line">python configure.py -q  /usr/lib64/qt4/bin/qmake</span><br><span class="line">make &amp; make install &amp; make clean</span><br></pre></td></tr></table></figure></p>
<p>这篇博客里用的是<strong>sip-4.17</strong>和<strong>PyQt-4.11.4</strong>是能够成功的一对版本。另外，Python2.7最高只能支持到PyQt4，PyQt5好像需要Python3.X的环境；同时Python2与Python3的兼容性也有些问题。所以为了避免版本上的麻烦，个人建议Python2还是老老实实用PyQt4，Python3的也使用对应的PyQt5。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://tripleday.github.io/2016/06/12/hello-world/</url>
      <content type="html"><![CDATA[<p>This is my <strong>first blog</strong> after I established this site using <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> and <a href="https://github.com/stiekel/hexo-theme-random" target="_blank" rel="external">random</a>.<br>Here are some tests for Hexo:</p>
<h1 id="Code-Test"><a href="#Code-Test" class="headerlink" title="Code Test:"></a>Code Test:</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<h1 id="Mathjax-Test"><a href="#Mathjax-Test" class="headerlink" title="Mathjax Test:"></a>Mathjax Test:</h1><p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$<br>\begin{eqnarray}<br>f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2<br>\end{eqnarray}<br>$$ </p>
<p>$$<br>\begin{eqnarray}<br>\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\<br>\nabla\cdot\vec{B} &amp;=&amp; 0 \\<br>\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\<br>\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)<br>\end{eqnarray}<br>$$</p>
<h1 id="PDF-Test"><a href="#PDF-Test" class="headerlink" title="PDF Test:"></a>PDF Test:</h1>

	<div class="row">
    <embed src="http://tripleday.cn/uploads/pdf/Clean%20Code.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="iFrame-Test"><a href="#iFrame-Test" class="headerlink" title="iFrame Test:"></a>iFrame Test:</h1><iframe src="http://www.seu.edu.cn/english/main.htm" width="100%" height="500" frameborder="0" allowfullscreen></iframe>
<h1 id="Picture-Test"><a href="#Picture-Test" class="headerlink" title="Picture Test:"></a>Picture Test:</h1><p><img src="/uploads/img/20160612/facebook.jpg" alt="Facebook"></p>
<h1 id="Youtube-Test"><a href="#Youtube-Test" class="headerlink" title="Youtube Test:"></a>Youtube Test:</h1><div class="video-container"><iframe src="//www.youtube.com/embed/https://youtu.be/QBJxGklvHRg" frameborder="0" allowfullscreen></iframe></div>
<h1 id="Youku-Test"><a href="#Youku-Test" class="headerlink" title="Youku Test:"></a>Youku Test:</h1><div class="video-container"><iframe height="480" width="100%" src="http://player.youku.com/embed/XMTU3NjExOTUwMA==" frameborder="0" allowfullscreen></iframe></div>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>http://tripleday.github.io/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://tripleday.github.io/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[About]]></title>
      <url>http://tripleday.github.io/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><p>My name is Haotian Wu(吴昊天). I’m a postgraduate student in <a href="http://cse.seu.edu.cn/en/index.html" target="_blank" rel="external">School of Computer Science &amp; Engineering</a> at <a href="http://www.seu.edu.cn/english/main.htm" target="_blank" rel="external">Southeast University</a> and will graduate in Summer 2018.</p>
<ul>
<li>Research Interests:<ul>
<li>Wireless and Mobile Networks</li>
<li>Network Economics</li>
<li>Web Information Retrieval</li>
<li>Data Mining &amp; Visualization</li>
</ul>
</li>
<li>Sports: <ul>
<li>Badminton</li>
<li>Swimming</li>
</ul>
</li>
</ul>
<h1 id="Contacts"><a href="#Contacts" class="headerlink" title="Contacts"></a>Contacts</h1><p>E-mail address: haotianwuseu # gmail # com.</p>
<p>Just to avoid spams, here is the Base64 code of my QQ number:<br><code>MTc3MjQ4MzM0Mg==</code></p>
<h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p><a href="http://1024ss.com" target="_blank" rel="external">1024ss.com</a>: 1024 Search Engine<br><a href="http://heimingx.cn" target="_blank" rel="external">Heiming’s Blog</a>: Haiming Xu（胥海明）’s blog</p>
]]></content>
    </entry>
    
  
</search>
